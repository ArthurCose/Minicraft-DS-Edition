#include "spritesheet.h"

#include <gl2d.h>
#include <_ansi.h>
#include "screen.h"

SpriteSheet::SpriteSheet(const unsigned char *bitmap, int width, int height, int tileW)
    : w(width), h(height), tileW(tileW)
{
  sassert(width == 256 && height == 256, "Only support TEXTURE_SIZE_256 for now");

  unsigned short palette[8] = {
      RGB15(0, 0, 0),
      RGB15(30, 0, 0),
      RGB15(0, 30, 0),
      RGB15(0, 0, 30),
      RGB15(30, 30, 0),
      RGB15(0, 30, 30),
      RGB15(30, 0, 30),
      RGB15(30, 30, 30),
  };

  tiles.resize((height / tileW) * (width / tileW));

  textureId =
      glLoadTileSet(
          &tiles[0],                                  // pointer to glImage array
          tileW,                                      // tile width
          tileW,                                      // tile height
          width,                                      // bitmap width
          height,                                     // bitmap height
          GL_RGB16,                                   // texture type for glTexImage2D() in videoGL.h
          TEXTURE_SIZE_256,                           // sizeX for glTexImage2D() in videoGL.h
          TEXTURE_SIZE_256,                           // sizeY for glTexImage2D() in videoGL.h
          TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
          8,                                          // Length of the palette to use
          palette,                                    //
          bitmap                                      // image data generated by GRIT
      );
}

static const int BIT_MIRROR_X = 0x01;
static const int BIT_MIRROR_Y = 0x02;

void SpriteSheet::renderTile(Screen &screen, int xp, int yp, int tile, int compressedColors, int bits)
{
  xp -= screen.xOffset;
  yp -= screen.yOffset;

  if (lastBoundPalette != compressedColors)
  {
    glSetActiveTexture(textureId);

    auto palettesIt = palettes.find(compressedColors);

    if (palettesIt == palettes.end())
    {
      TilePalette &palette = *palettes.emplace(compressedColors, std::make_unique<TilePalette>(compressedColors)).first->second;
      palette.assignToActiveTexture();
    }
    else
    {
      TilePalette &palette = *palettesIt->second;
      palette.assignToActiveTexture();
    }

    lastBoundPalette = compressedColors;
  }

  // convert to GL_FLIP_H and GL_FLIP_V
  int flipMode = ((bits & BIT_MIRROR_X) << 2) | (bits & BIT_MIRROR_Y);

  glSprite(xp, yp, flipMode, &tiles[tile]);
}
