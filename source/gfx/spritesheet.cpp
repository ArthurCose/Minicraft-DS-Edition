#include "spritesheet.h"

#include <gl2d.h>
#include <_ansi.h>
#include "glscreen.h"
#include "softwarescreen.h"

SpriteSheet::SpriteSheet(const unsigned char *bitmap, int width, int height, int tileW)
    : bitmap(bitmap), w(width), h(height), tileW(tileW)
{
  sassert(width == 256 && height == 256, "Only support TEXTURE_SIZE_256 for now");

  unsigned short palette[8] = {
      RGB15(0, 0, 0),
      RGB15(30, 0, 0),
      RGB15(0, 30, 0),
      RGB15(0, 0, 30),
      RGB15(30, 30, 0),
      RGB15(0, 30, 30),
      RGB15(30, 0, 30),
      RGB15(30, 30, 30),
  };

  tiles.resize((height / tileW) * (width / tileW));

  textureId =
      glLoadTileSet(
          &tiles[0],                                  // pointer to glImage array
          tileW,                                      // tile width
          tileW,                                      // tile height
          width,                                      // bitmap width
          height,                                     // bitmap height
          GL_RGB16,                                   // texture type for glTexImage2D() in videoGL.h
          TEXTURE_SIZE_256,                           // sizeX for glTexImage2D() in videoGL.h
          TEXTURE_SIZE_256,                           // sizeY for glTexImage2D() in videoGL.h
          TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
          8,                                          // Length of the palette to use
          palette,                                    //
          bitmap                                      // image data generated by GRIT
      );
}

static const int BIT_MIRROR_X = 0x01;
static const int BIT_MIRROR_Y = 0x02;

void SpriteSheet::renderTile(GLScreen &screen, int xp, int yp, int tile, int compressedColors, int bits)
{
  xp -= screen.xOffset;
  yp -= screen.yOffset;

  if (lastBoundPalette != compressedColors)
  {
    glSetActiveTexture(textureId);

    auto palettesIt = palettes.find(compressedColors);

    if (palettesIt == palettes.end())
    {
      TilePalette &palette = *palettes.emplace(compressedColors, std::make_unique<TilePalette>(compressedColors)).first->second;
      palette.assignToActiveTexture();
    }
    else
    {
      TilePalette &palette = *palettesIt->second;
      palette.assignToActiveTexture();
    }

    lastBoundPalette = compressedColors;
  }

  // convert to GL_FLIP_H and GL_FLIP_V
  int flipMode = ((bits & BIT_MIRROR_X) << 2) | (bits & BIT_MIRROR_Y);

  glSprite(xp, yp, flipMode, &tiles[tile]);
}

void SpriteSheet::renderTile(SoftwareScreen &screen, int xp, int yp, int tile, int compressedColors, int bits)
{
  xp -= screen.xOffset;
  yp -= screen.yOffset;

  bool mirrorX = (bits & BIT_MIRROR_X) > 0;
  bool mirrorY = (bits & BIT_MIRROR_Y) > 0;

  int tileX = tile % 32;
  int tileY = tile / 32;
  int tileOffset = tileX * 8 + tileY * 8 * w;

  int colors[5] = {
      255,
      (compressedColors >> (0 * 8)) & 255,
      (compressedColors >> (1 * 8)) & 255,
      (compressedColors >> (2 * 8)) & 255,
      (compressedColors >> (3 * 8)) & 255};

  for (int y = 0; y < 8; y++)
  {
    int ys = y;
    if (mirrorY)
      ys = 7 - y;
    if (y + yp < 0 || y + yp >= h)
      continue;
    for (int x = 0; x < 8; x++)
    {
      if (x + xp < 0 || x + xp >= w)
        continue;

      int xs = x;
      if (mirrorX)
        xs = 7 - x;

      int bitmapIndex = ys * w + xs + tileOffset;

      int colorIndex = bitmap[bitmapIndex / 2] >> (bitmapIndex % 2 * 4) & 15;

      int col = colors[colorIndex];

      if (col < 255)
        screen.pixels[(x + xp) + (y + yp) * w] = col;
    }
  }
}
